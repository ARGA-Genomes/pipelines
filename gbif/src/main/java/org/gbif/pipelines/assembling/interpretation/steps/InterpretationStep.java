package org.gbif.pipelines.assembling.interpretation.steps;

import org.gbif.pipelines.config.InterpretationType;
import org.gbif.pipelines.io.avro.ExtendedRecord;
import org.gbif.pipelines.io.avro.OccurrenceIssue;
import org.gbif.pipelines.transform.Kv2Value;
import org.gbif.pipelines.transform.RecordTransform;

import java.util.Objects;
import java.util.function.Function;

import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.io.AvroIO;
import org.apache.beam.sdk.io.FileSystems;
import org.apache.beam.sdk.values.PCollection;
import org.apache.beam.sdk.values.PCollectionTuple;

/**
 * Defines an interpretation step of a {@link Pipeline}.
 */
public class InterpretationStep<T> {

  private static final String WRITE_DATA_MSG_PATTERN = "Write %s data to avro";
  private static final String WRITE_ISSUES_MSG_PATTERN = "Write %s issues to avro";

  // type of the interpretation
  private final InterpretationType interpretationType;
  // avro class of the result generated by this step
  private final Class<T> avroClass;
  // PTransformation to transfotm ExtendedRecord to T
  private final RecordTransform<ExtendedRecord, T> transform;
  // generates the necessary paths
  private Function<InterpretationType, PipelineTargetPaths> pathsGenerator;

  private InterpretationStep(Builder<T> builder) {
    this.interpretationType = builder.interpretationType;
    this.avroClass = builder.avroClass;
    this.transform = builder.transform;
    this.pathsGenerator = builder.pathsGenerator;
  }

  public static <T> InterpretationTypeStep<T> newBuilder() {
    return new Builder<>();
  }

  /**
   * Appends the current of this interpretation step to the desired {@link Pipeline}.
   *
   * @param extendedRecords {@link PCollection} with the records that are gonna be interpreted by this step.
   */
  public void appendToPipeline(PCollection<ExtendedRecord> extendedRecords, Pipeline pipeline) {
    // add coders
    transform.withAvroCoders(pipeline);

    // apply transformation
    PCollectionTuple interpretedRecordTuple = extendedRecords.apply(transform);

    // generate paths
    PipelineTargetPaths paths = pathsGenerator.apply(interpretationType);

    // Get data and save it to an avro file
    PCollection<T> interpretedRecords = interpretedRecordTuple.get(transform.getDataTag()).apply(Kv2Value.create());
    if (interpretedRecords != null) {
      interpretedRecords.apply(String.format(WRITE_DATA_MSG_PATTERN, interpretationType.name()),
                               createAvroWriter(avroClass, paths.getDataTargetPath(), paths.getTempDir()));
    }

    // Get issues and save them to an avro file
    PCollection<OccurrenceIssue> issues = interpretedRecordTuple.get(transform.getIssueTag()).apply(Kv2Value.create());
    if (issues != null) {
      issues.apply(String.format(WRITE_ISSUES_MSG_PATTERN, interpretationType.name()),
                   createAvroWriter(OccurrenceIssue.class, paths.getIssuesTargetPath(), paths.getTempDir()));
    }
  }

  private <U> AvroIO.Write<U> createAvroWriter(Class<U> avroClass, String path, String tempDir) {
    Preconditions.checkArgument(!Strings.isNullOrEmpty(path), "Target path is required");
    AvroIO.Write<U> writer = AvroIO.write(avroClass).to(path).withoutSharding().withSuffix(".avro");

    return Strings.isNullOrEmpty(tempDir)
      ? writer
      : writer.withTempDirectory(FileSystems.matchNewResource(tempDir, true));
  }

  private static class Builder<T> implements Build, InterpretationTypeStep, AvroClassStep, TransformStep, PathsGeneratorStep {

    private InterpretationType interpretationType;
    private Class<T> avroClass;
    private RecordTransform<ExtendedRecord, T> transform;
    private Function<InterpretationType, PipelineTargetPaths> pathsGenerator;

    @Override
    public AvroClassStep<T> interpretationType(InterpretationType interpretationType) {
      Objects.requireNonNull(interpretationType, "Interpretation type cannot be null");
      this.interpretationType = interpretationType;
      return this;
    }

    @Override
    public TransformStep<T> avroClass(Class avroClass) {
      Objects.requireNonNull(avroClass, "Avro class cannot be null");
      this.avroClass = avroClass;
      return this;
    }

    @Override
    public PathsGeneratorStep<T> transform(RecordTransform transform) {
      Objects.requireNonNull(transform, "RecordTransform cannot be null");
      this.transform = transform;
      return this;
    }

    @Override
    public Build pathsGenerator(Function pathsGenerator) {
      Objects.requireNonNull(pathsGenerator);
      this.pathsGenerator = pathsGenerator;
      return this;
    }

    @Override
    public InterpretationStep<T> build() {
      return new InterpretationStep<>(this);
    }
  }

  public interface InterpretationTypeStep<T> {

    AvroClassStep<T> interpretationType(InterpretationType interpretationType);
  }

  public interface AvroClassStep<T> {

    TransformStep<T> avroClass(Class<T> avroClass);
  }

  public interface TransformStep<T> {

    PathsGeneratorStep<T> transform(RecordTransform<ExtendedRecord, T> transform);
  }

  public interface PathsGeneratorStep<T> {

    Build<T> pathsGenerator(Function<InterpretationType, PipelineTargetPaths> pathsGenerator);
  }

  public interface Build<T> {

    InterpretationStep<T> build();
  }

}
