package org.gbif.pipelines.assembling.pipelines;

import org.gbif.pipelines.config.InterpretationType;
import org.gbif.pipelines.io.avro.ExtendedRecord;
import org.gbif.pipelines.io.avro.OccurrenceIssue;
import org.gbif.pipelines.transform.Kv2Value;
import org.gbif.pipelines.transform.RecordTransform;

import java.util.Objects;

import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.io.AvroIO;
import org.apache.beam.sdk.values.PCollection;
import org.apache.beam.sdk.values.PCollectionTuple;

/**
 * Defines an interpretation step of a {@link Pipeline}.
 */
public class InterpretationStep<T> {

  private static final String WRITE_DATA_MSG_PATTERN = "Write %s data to avro";
  private static final String WRITE_ISSUES_MSG_PATTERN = "Write %s issues to avro";

  // type of the interpretation
  private final InterpretationType interpretationType;
  // avro class of the result generated by this step
  private final Class<T> avroClass;
  // PTransformation to transfotm ExtendedRecord to T
  private final RecordTransform<ExtendedRecord, T> transform;
  // path where data will be written to
  private final String dataTargetPath;
  // path where issues will be written to
  private final String issuesTargetPath;

  private InterpretationStep(Builder<T> builder) {
    this.interpretationType = builder.interpretationType;
    this.avroClass = builder.avroClass;
    this.transform = builder.transform;
    this.dataTargetPath = builder.dataTargetPath;
    this.issuesTargetPath = builder.issuesTargetPath;
  }

  public static <T> InterpretationTypeStep<T> newBuilder() {
    return new Builder<>();
  }

  /**
   * Appends the current of this interpretation step to the desired {@link Pipeline}.
   *
   * @param extendedRecords {@link PCollection} with the records that are gonna be interpreted by this step.
   * @param pipeline        {@link Pipeline} to append this step to.
   */
  public void appendToPipeline(PCollection<ExtendedRecord> extendedRecords, Pipeline pipeline) {
    // apply transformation
    PCollectionTuple interpretedRecordTuple = extendedRecords.apply(transform);

    // Get data and save it to an avro file
    PCollection<T> interpretedRecords = interpretedRecordTuple.get(transform.getDataTag()).apply(Kv2Value.create());

    interpretedRecords.apply(String.format(WRITE_DATA_MSG_PATTERN, interpretationType.name()),
                             AvroIO.write(avroClass).to(dataTargetPath).withoutSharding());

    // Get issues and save them to an avro file
    PCollection<OccurrenceIssue> issues = interpretedRecordTuple.get(transform.getIssueTag()).apply(Kv2Value.create());
    issues.apply(String.format(WRITE_ISSUES_MSG_PATTERN, interpretationType.name()),
                 AvroIO.write(OccurrenceIssue.class).to(issuesTargetPath).withoutSharding());
  }

  private static class Builder<T>
    implements Build, InterpretationTypeStep, AvroClassStep, TransformStep, DataTargetPathStep, IssuesTargetPathStep {

    private InterpretationType interpretationType;
    private Class<T> avroClass;
    private RecordTransform<ExtendedRecord, T> transform;
    private String dataTargetPath;
    private String issuesTargetPath;

    @Override
    public AvroClassStep interpretationType(InterpretationType interpretationType) {
      Objects.requireNonNull(interpretationType);
      this.interpretationType = interpretationType;
      return this;
    }

    @Override
    public TransformStep avroClass(Class avroClass) {
      Objects.requireNonNull(avroClass);
      this.avroClass = avroClass;
      return this;
    }

    @Override
    public DataTargetPathStep transform(RecordTransform transform) {
      Objects.requireNonNull(transform);
      this.transform = transform;
      return this;
    }

    @Override
    public IssuesTargetPathStep dataTargetPath(String dataTargetPath) {
      Objects.requireNonNull(dataTargetPath);
      this.dataTargetPath = dataTargetPath;
      return this;
    }

    @Override
    public Build issuesTargetPath(String issuesTargetPath) {
      Objects.requireNonNull(issuesTargetPath);
      this.issuesTargetPath = issuesTargetPath;
      return this;
    }

    @Override
    public InterpretationStep<T> build() {
      return new InterpretationStep<>(this);
    }
  }

  public interface InterpretationTypeStep<T> {

    AvroClassStep<T> interpretationType(InterpretationType interpretationType);
  }

  public interface AvroClassStep<T> {

    TransformStep<T> avroClass(Class<T> avroClass);
  }

  public interface TransformStep<T> {

    DataTargetPathStep<T> transform(RecordTransform<ExtendedRecord, T> transform);
  }

  public interface DataTargetPathStep<T> {

    IssuesTargetPathStep<T> dataTargetPath(String dataTargetPath);
  }

  public interface IssuesTargetPathStep<T> {

    Build<T> issuesTargetPath(String issuesTargetPath);
  }

  public interface Build<T> {

    InterpretationStep<T> build();
  }

}
